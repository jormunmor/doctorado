<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 8. Exhaustive Search</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="OptaPlanner User Guide"/><link rel="up" href="index.html" title="OptaPlanner User Guide"/><link rel="prev" href="ch07.html" title="Chapter 7. Move and neighborhood selection"/><link rel="next" href="ch09.html" title="Chapter 9. Construction heuristics"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch07.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch09.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 8. Exhaustive Search"><div class="titlepage"><div><div><h2 class="title"><a id="exhaustiveSearch"/>Chapter 8. Exhaustive Search</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch08.html#exhaustiveSearchOverview">8.1. Overview</a></span></dt><dt><span class="section"><a href="ch08.html#bruteForce">8.2. Brute Force</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#bruteForceAlgorithm">8.2.1. Algorithm description</a></span></dt><dt><span class="section"><a href="ch08.html#bruteForceConfiguration">8.2.2. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#branchAndBound">8.3. Branch And Bound</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#branchAndBoundAlgorithm">8.3.1. Algorithm description</a></span></dt><dt><span class="section"><a href="ch08.html#branchAndBoundConfiguration">8.3.2. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#scalabilityOfExhaustiveSearch">8.4. Scalability of Exhaustive Search</a></span></dt></dl></div><div class="section" title="8.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="exhaustiveSearchOverview"/>8.1. Overview</h2></div></div></div><p>Exhaustive Search will always find the global optimum and recognize it too. That being said, it doesn't scale (not
    even beyond toy data sets) and is therefore mostly useless.</p></div><div class="section" title="8.2. Brute Force"><div class="titlepage"><div><div><h2 class="title"><a id="bruteForce"/>8.2. Brute Force</h2></div></div></div><div class="section" title="8.2.1. Algorithm description"><div class="titlepage"><div><div><h3 class="title"><a id="bruteForceAlgorithm"/>8.2.1. Algorithm description</h3></div></div></div><p>The Brute Force algorithm creates and evaluates every possible solution.</p><div class="mediaobject"><img src="images/Chapter-Exhaustive_search/bruteForceNQueens04.png"/></div><p>Notice that it creates a search tree that explodes exponentially as the problem size increases, so it hits a
      scalability wall.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p><span class="bold"><strong>Brute Force is mostly unusable for a real-world problem due to time
        limitations</strong></span>, as shown in <a class="link" href="ch08.html#scalabilityOfExhaustiveSearch" title="8.4. Scalability of Exhaustive Search">scalability of Exhaustive
        Search</a>.</p></div></div><div class="section" title="8.2.2. Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="bruteForceConfiguration"/>8.2.2. Configuration</h3></div></div></div><p>Simplest configuration of Brute Force:</p><pre><code class="language-xml">&lt;solver&gt;
  ...
  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRUTE_FORCE&lt;/exhaustiveSearchType&gt;
  &lt;/exhaustiveSearch&gt;
&lt;/solver&gt;</code></pre></div></div><div class="section" title="8.3. Branch And Bound"><div class="titlepage"><div><div><h2 class="title"><a id="branchAndBound"/>8.3. Branch And Bound</h2></div></div></div><div class="section" title="8.3.1. Algorithm description"><div class="titlepage"><div><div><h3 class="title"><a id="branchAndBoundAlgorithm"/>8.3.1. Algorithm description</h3></div></div></div><p>Branch And Bound also explores nodes in an exponential search tree, but it investigates more promising nodes
      first and prunes away worthless nodes.</p><p>For each node, Branch And Bound calculates the optimistic bound: the best possible score to which that node
      can lead to. If the optimistic bound of a node is lower or equal to the global pessimistic bound, then it prunes
      away that node (including the entire branch of all its subnodes).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Academic papers use the term lower bound instead of optimistic bound (and the term upper bound instead of
        pessimistic bound), because they minimize the score.</p><p>Planner maximizes the score (because it supports combining negative and positive constraints).
        Therefore, for clarity, it uses different terms, as it would be confusing to use the term lower bound
        for a bound which is always higher.</p></div><p>For example: at index 15, it can prune away all unvisited solutions with queen A on row 0, because none will
      be better than the solution of index 14 with a score of <code class="literal">-1</code>.</p><div class="mediaobject"><img src="images/Chapter-Exhaustive_search/depthFirstBranchAndBoundNQueens04.png"/></div><p>Notice that Branch And Bound (much like <a class="link" href="ch08.html#bruteForce" title="8.2. Brute Force">Brute Force</a>) creates a search tree
      that explodes exponentially as the problem size increases. So it hits the same scalability wall, only a little bit
      later.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p><span class="bold"><strong>Branch And Bound is mostly unusable for a real-world problem due to time
        limitations</strong></span>, as shown in <a class="link" href="ch08.html#scalabilityOfExhaustiveSearch" title="8.4. Scalability of Exhaustive Search">scalability of Exhaustive
        Search</a>.</p></div></div><div class="section" title="8.3.2. Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="branchAndBoundConfiguration"/>8.3.2. Configuration</h3></div></div></div><p>Simplest configuration of Branch And Bound:</p><pre><code class="language-xml">&lt;solver&gt;
  ...
  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
  &lt;/exhaustiveSearch&gt;
&lt;/solver&gt;</code></pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>For the pruning to work with the default <code class="literal">ScoreBounder</code>, the <a class="link" href="ch05.html#initializingScoreTrend" title="5.3.5. InitializingScoreTrend">InitializingScoreTrend</a> should be set. Especially an <a class="link" href="ch05.html#initializingScoreTrend" title="5.3.5. InitializingScoreTrend">InitializingScoreTrend</a> of <code class="literal">ONLY_DOWN</code> (or at least has
        <code class="literal">ONLY_DOWN</code> in the leading score levels) prunes a lot.</p></div><p>Advanced configuration:</p><pre><code class="language-xml">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;DEPTH_FIRST&lt;/nodeExplorationType&gt;
    &lt;entitySorterManner&gt;DECREASING_DIFFICULTY_IF_AVAILABLE&lt;/entitySorterManner&gt;
    &lt;valueSorterManner&gt;INCREASING_STRENGTH_IF_AVAILABLE&lt;/valueSorterManner&gt;
  &lt;/exhaustiveSearch&gt;</code></pre><p>The <code class="literal">nodeExplorationType</code> options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">DEPTH_FIRST</code> (default): Explore deeper nodes first (and then a better score and then a
          better optimistic bound). Deeper nodes (especially leaf nodes) often improve the pessimistic bound. A better
          pessimistic bound allows pruning more nodes to reduce the search space.</p><pre><code class="language-xml">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;DEPTH_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</code></pre></li><li class="listitem"><p><code class="literal">BREADTH_FIRST</code> (not recommended): Explore nodes layer by layer (and then a better
          score and then a better optimistic bound). Scales terribly in memory (and usually in performance too).</p><pre><code class="language-xml">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;BREADTH_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</code></pre></li><li class="listitem"><p><code class="literal">SCORE_FIRST</code>: Explore nodes with a better score first (and then a better optimistic
          bound and then deeper nodes first). Might scale as terribly as <code class="literal">BREADTH_FIRST</code> in some
          cases.</p><pre><code class="language-xml">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;SCORE_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</code></pre></li><li class="listitem"><p><code class="literal">OPTIMISTIC_BOUND_FIRST</code>: Explore nodes with a better optimistic bound first (and then
          a better score and then deeper nodes first). Might scale as terribly as <code class="literal">BREADTH_FIRST</code> in
          some cases.</p><pre><code class="language-xml">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;OPTIMISTIC_BOUND_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</code></pre></li></ul></div><p>The <code class="literal">entitySorterManner</code> options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">DECREASING_DIFFICULTY</code>: Initialize the more difficult planning entities first. This
          usually increases pruning (and therefore improves scalability). Requires the model to support <a class="link" href="ch04.html#planningEntityDifficulty" title="4.3.3.2. Planning entity difficulty">planning entity difficulty comparison</a>.</p></li><li class="listitem"><p><code class="literal">DECREASING_DIFFICULTY_IF_AVAILABLE</code> (default): If the model supports <a class="link" href="ch04.html#planningEntityDifficulty" title="4.3.3.2. Planning entity difficulty">planning entity difficulty comparison</a>, behave like
          <code class="literal">DECREASING_DIFFICULTY</code>, else like <code class="literal">NONE</code>.</p></li><li class="listitem"><p><code class="literal">NONE</code>: Initialize the planning entities in original order.</p></li></ul></div><p>The <code class="literal">valueSorterManner</code> options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">INCREASING_STRENGTH</code>: Evaluate the planning values in increasing strength. Requires
          the model to support <a class="link" href="ch04.html#planningValueStrength" title="4.3.5.3. Planning value strength">planning value strength comparison</a>.</p></li><li class="listitem"><p><code class="literal">INCREASING_STRENGTH_IF_AVAILABLE</code> (default): If the model supports <a class="link" href="ch04.html#planningValueStrength" title="4.3.5.3. Planning value strength">planning value strength comparison</a>, behave like
          <code class="literal">INCREASING_STRENGTH</code>, else like <code class="literal">NONE</code>.</p></li><li class="listitem"><p><code class="literal">DECREASING_STRENGTH</code>: Evaluate the planning values in decreasing strength. Requires
          the model to support <a class="link" href="ch04.html#planningValueStrength" title="4.3.5.3. Planning value strength">planning value strength comparison</a>.</p></li><li class="listitem"><p><code class="literal">DECREASING_STRENGTH_IF_AVAILABLE</code>: If the model supports <a class="link" href="ch04.html#planningValueStrength" title="4.3.5.3. Planning value strength">planning value strength comparison</a>, behave like
          <code class="literal">DECREASING_STRENGTH</code>, else like <code class="literal">NONE</code>.</p></li><li class="listitem"><p><code class="literal">NONE</code>: Try the planning values in original order.</p></li></ul></div></div></div><div class="section" title="8.4. Scalability of Exhaustive Search"><div class="titlepage"><div><div><h2 class="title"><a id="scalabilityOfExhaustiveSearch"/>8.4. Scalability of Exhaustive Search</h2></div></div></div><p>Exhaustive Search variants suffer from 2 big scalability issues:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They scale terribly memory wise.</p></li><li class="listitem"><p>They scale horribly performance wise.</p></li></ul></div><p>As shown in these time spent graphs from the <a class="link" href="ch14.html" title="Chapter 14. Benchmarking and tweaking">Benchmarker</a>, Brute
    Force and Branch And Bound both hit a performance scalability wall. For example, on N queens it hits wall at a few
    dozen queens:</p><div class="mediaobject"><img src="images/Chapter-Exhaustive_search/exhaustiveSearchScalabilityNQueens.png"/></div><p>In most use cases, such as Cloud Balancing, the wall appears out of thin air:</p><div class="mediaobject"><img src="images/Chapter-Exhaustive_search/exhaustiveSearchScalabilityCloudBalance.png"/></div><p><span class="bold"><strong>Exhaustive Search hits this wall on small datasets already, so in production these
    optimizations algorithms are mostly useless.</strong></span> Use Construction Heuristics with Local Search instead: those
    can handle thousands of queens/computers easily.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Throwing hardware at these scalability issues has no noticeable impact. Newer and more hardware are just a
      drop in the ocean. Moore's law cannot win against the onslaught of a few more planning entities in the
      dataset.</p></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-39485370-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><ul class="docnav"><li class="previous"><a accesskey="p" href="ch07.html"><strong>Prev</strong>Chapter 7. Move and neighborhood selection</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch09.html"><strong>Next</strong>Chapter 9. Construction heuristics</a></li></ul></body></html>